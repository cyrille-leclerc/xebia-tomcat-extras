/* * Copyright 2009-2010 Xebia and the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package fr.xebia.catalina.listener;import java.io.IOException;import java.net.InetSocketAddress;import java.net.Proxy;import java.net.ProxySelector;import java.net.SocketAddress;import java.net.URI;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import org.apache.catalina.Lifecycle;import org.apache.catalina.LifecycleEvent;import org.apache.catalina.LifecycleListener;import org.apache.catalina.util.StringManager;import org.apache.juli.logging.Log;import org.apache.juli.logging.LogFactory;/** * <p> * Tomcat {@link LifecycleListener} to define an inclusive ProxySelector as the * default {@link ProxySelector} of the JVM (see * {@link ProxySelector#getDefault()} ) at Tomcat startup. If the given host * does not match an entry of the proxied hosts list, the inclusive proxy * selector delegates JVM initial ProxySelector. * <p> * <p> * An inclusive ProxySelector allows to define the list of host for which a * {@link Proxy} will be used. The out-of-the-box ProxySelector follows the * opposite approach being exclusive : the configured proxy is used for all the * hosts at the exception of the host enumerated in the * <code>nonProxyHosts</code> variable. * </p> * <p> * Configuration sample: * </p> * <code><pre> * &lt;Listener  *    className="fr.xebia.catalina.listener.DefaultProxySelectorConfigurerListener"  *    proxy="http-proxy:3128"  *    proxiedHosts="server-foo, server-bar, www\.example\.com" /&gt; * </pre></code> * <p> * HTTP calls to URL with hostname <code>server-foo</code>, * <code>server-bar</code> and <code>www.example.com</code> will use proxy * <code>http-proxy:3128</code>. * </p> * <p> * Advanced configuration sample: * </p> * <code><pre> * &lt;Listener  *    className="fr.xebia.catalina.listener.DefaultProxySelectorConfigurerListener"  *    proxy="http-proxy:3128"  *    proxiedHosts="server-.*" /&gt; *    excludedProxiedHosts="server-foo" /&gt; * </pre></code> * <p> * HTTP calls to URL with hostname starting with <code>server-</code> will use * proxy <code>http-proxy:3128</code> except requests to host * <code>server-foo</code>. * </p> *  * @author <a href="mailto:cyrille@cyrilleleclerc.com">Cyrille Le Clerc</a> */public class DefaultProxySelectorConfigurerListener implements LifecycleListener {    public class ConfigurableProxySelector extends ProxySelector {        @Override        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {            if (log.isDebugEnabled()) {                log.debug("connectFailed(uri=" + uri + "sa=" + sa + "ioe=" + ioe + ")");            }            if (("http".equals(uri.getScheme()) || "https".equals(uri.getScheme())) && matchesOne(uri.getHost(), proxiedHosts)                    && !matchesOne(uri.getHost(), excludedProxiedHosts)) {                // do nothing            } else {                fallbackProxySelector.connectFailed(uri, sa, ioe);            }        }        @Override        public List<Proxy> select(URI uri) {            if (log.isDebugEnabled()) {                log.debug("> select(uri=" + uri + ")");            }            List<Proxy> result;            if (("http".equals(uri.getScheme()) || "https".equals(uri.getScheme())) && matchesOne(uri.getHost(), proxiedHosts)                    && !matchesOne(uri.getHost(), excludedProxiedHosts)) {                result = proxies;            } else {                result = fallbackProxySelector.select(uri);            }            if (log.isDebugEnabled()) {                log.debug("< select(uri=" + uri + ") : " + result);            }            return result;        }    }    /**     * {@link Pattern} for a comma delimited string that support whitespace     * characters     */    private static final Pattern commaSeparatedValuesPattern = Pattern.compile("\\s*,\\s*");    private static Log log = LogFactory.getLog(DefaultProxySelectorConfigurerListener.class);    /**     * The StringManager for this package.     */    protected static StringManager sm = StringManager.getManager("fr.xebia.catalina.listener");    /**     * Convert a given comma delimited list of regular expressions into an array     * of compiled {@link Pattern}     *      * @return array of patterns (not <code>null</code>)     */    protected static Pattern[] commaDelimitedListToPatternArray(String commaDelimitedPatterns) {        String[] patterns = commaDelimitedListToStringArray(commaDelimitedPatterns);        List<Pattern> patternsList = new ArrayList<Pattern>();        for (String pattern : patterns) {            try {                patternsList.add(Pattern.compile(pattern));            } catch (PatternSyntaxException e) {                throw new IllegalArgumentException(sm.getString("DefaultProxySelectorConfigurerListener.proxiesHostPatternSyntax",                        pattern), e);            }        }        return patternsList.toArray(new Pattern[0]);    }    /**     * Convert a given comma delimited list of regular expressions into an array     * of String     *      * @return array of patterns (non <code>null</code>)     */    protected static String[] commaDelimitedListToStringArray(String commaDelimitedStrings) {        return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0] : commaSeparatedValuesPattern                .split(commaDelimitedStrings);    }    /**     * Convert an array of strings in a comma delimited string     */    protected static String listToCommaDelimitedString(List<?> list) {        if (list == null) {            return "";        }        StringBuilder result = new StringBuilder();        for (Iterator<?> it = list.iterator(); it.hasNext();) {            Object element = it.next();            if (element != null) {                result.append(element);                if (it.hasNext()) {                    result.append(", ");                }            }        }        return result.toString();    }    /**     * Return <code>true</code> if the given <code>str</code> matches at least     * one of the given <code>patterns</code>.     */    protected static boolean matchesOne(String str, Pattern... patterns) {        for (Pattern pattern : patterns) {            if (pattern.matcher(str).matches()) {                return true;            }        }        return false;    }    protected ProxySelector fallbackProxySelector;    protected Pattern[] proxiedHosts = new Pattern[0];    protected Pattern[] excludedProxiedHosts = new Pattern[0];    protected List<Proxy> proxies;    public String getProxiedHosts() {        return listToCommaDelimitedString(Arrays.asList(proxiedHosts));    }    public String getExcludedProxiedHosts() {        return listToCommaDelimitedString(Arrays.asList(excludedProxiedHosts));    }    public String getProxy() {        return listToCommaDelimitedString(proxies);    }    public void lifecycleEvent(LifecycleEvent event) {        if (Lifecycle.BEFORE_START_EVENT.equals(event.getType())) {            this.fallbackProxySelector = ProxySelector.getDefault();            ProxySelector proxySelector = new ConfigurableProxySelector();            ProxySelector.setDefault(proxySelector);        } else if (Lifecycle.AFTER_STOP_EVENT.equals(event.getType())) {            ProxySelector.setDefault(fallbackProxySelector);        }    }    /**     * <p>     * Comma delimited hostnames that require proxification. The hostnames are     * expressed using Java regular expression syntax.     * </p>     * <p>     * Sample : 10\.\d{1,3}\.\d{1,3}\.\d{1,3}, another-proxied-server     * </p>     */    public void setProxiedHosts(String commaDelimitedHosts) {        this.proxiedHosts = commaDelimitedListToPatternArray(commaDelimitedHosts);    }    /**     * <p>     * Comma delimited hostnames that must not be proxied. The hostnames are     * expressed using Java regular expression syntax.     * </p>     * <p>     * Sample : internal-server-.*     * </p>     */    public void setExcludedProxiedHosts(String commaDelimitedHosts) {        this.excludedProxiedHosts = commaDelimitedListToPatternArray(commaDelimitedHosts);    }    /**     * Colon separated proxy host and port (e.g. my-proxy:8080).     */    public void setProxy(String proxyHostPort) {        String[] proxyHostPortAsArray = proxyHostPort.split(":");        if (proxyHostPortAsArray.length != 2) {            throw new IllegalArgumentException("Expected colon separated 'proxyHost:proxyPort' ; not supported '" + proxyHostPort + "'");        }        String proxyHost = proxyHostPortAsArray[0];        int proxyPort;        try {            proxyPort = Integer.valueOf(proxyHostPortAsArray[1]);        } catch (NumberFormatException e) {            throw new IllegalArgumentException("Unsupported port '" + proxyHostPortAsArray[1] + "' for host '" + proxyHost                    + "' and proxyHost '" + proxyHost + "'");        }        this.proxies = Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)));    }}